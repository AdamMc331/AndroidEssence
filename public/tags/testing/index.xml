<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testing on Android Essence</title>
    <link>http://localhost:1313/tags/testing/</link>
    <description>Recent content in Testing on Android Essence</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting Started With Test Driven Development</title>
      <link>http://localhost:1313/posts/2020-03-02-test-driven-development/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/2020-03-02-test-driven-development/</guid>
      
      <description>&lt;p&gt;One of the many buzzwords thrown around the software devleopment community is Test Driven Development, or TDD. It is one of those phrases that sounds great when you say it - who wouldn&amp;rsquo;t want to have tests be their first priority when writing code?&lt;/p&gt;
&lt;p&gt;However, it&amp;rsquo;s not always clear what TDD means. Does it mean you write code with testability in mind? Does it mean writing tests first? How can we write tests if we don&amp;rsquo;t have code &lt;em&gt;to&lt;/em&gt; test? This post will answer all of those questions, and teach you how to implement TDD effectively on Android.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Unit Testing RxJava or Coroutine Code With Constructor Injection</title>
      <link>http://localhost:1313/posts/2019-04-30-unit-testing-async-code/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/2019-04-30-unit-testing-async-code/</guid>
      
      <description>&lt;p&gt;Putting aside the long lasting debate right now about whether you should use RxJava or coroutines for your asynchronous code on Android, both camps often hit the same problem. How do I write unit tests for this?&lt;/p&gt;
&lt;p&gt;Unit testing asynchronous code is tricky, because we may need to know how to properly test callback APIs, or perhaps we just want things to run instantly and not worry about thread changes. We may also be wondering how to handle not having a &amp;ldquo;main&amp;rdquo; thread in a junit test, unlike a connected test. This post will be focusing on handling that last one.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Leveraging The Robot Pattern For Espresso Tests</title>
      <link>http://localhost:1313/posts/2017-07-04-leveraging-the-robot-pattern-for-espresso-tests/</link>
      <pubDate>Tue, 04 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/2017-07-04-leveraging-the-robot-pattern-for-espresso-tests/</guid>
      
      <description>&lt;p&gt;Espresso is a &lt;a href=&#34;https://developer.android.com/training/testing/ui-testing/espresso-testing.html&#34;&gt;testing framework for Android&lt;/a&gt; that allows developers to write automated tests for their applications. The benefit of automated testing is that you can write a test plan, and simply hit run and have all of the important features in your app tested effortlessly, and arguably more consistent and thorough than manual testing. There is no doubt that it is a lot faster.&lt;/p&gt;
&lt;p&gt;However, one of the lesser known development patterns for automated testing is the robot pattern, which makes writing tests much easier while providing a painless way to update tests whenever your app changes. Let&amp;rsquo;s take a deeper dive into what makes the robot pattern so powerful, and how to implement it in your next test suite.&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
